  #' Compute Bellman values at step i from step i+1
  #'
  #' @param Data_week A "data.table" generated in Grid_Matrix code
  #' that contains:
  #'  * states Numeric. All the water values that can be set, listed in
  #'   decreasing order.
  #'  * value_inflow Numeric. Inflow values for each Monte-Carlo year.
  #'  * Rewards for each simulation value and each Monte-Carlo year.
  #'  * level_high Numeric. Highest possible reservoir value.
  #'  * level_low Numeric. Lowest possible reservoir value.
  #'  * states_next List of vectors enumerating all reachable states
  #' @param decision_space Simulation constraints values
  #' @param next_week_values_l Numeric. Bellman values at step i+1.
  #' @param niveau_max Numeric of length 1. Reservoir capacity.
  #' @param E_max Numeric of length 1. Maximum energy that can be generated by
  #'   hydro storage over one step of time.
  #' @param P_max Numeric of length 1. Maximum energy that can be pumped to
  #' reservoir over one step of time.
  #' @param method Character. Perform mean of grids algorithm or grid of means algorithm or
  #'  grid of quantile algorithm.
  #' @param na_rm Boolean. Remove NAs
  #' @param max_mcyear Numeric of length 1. Number of Monte-Carlo year
  #'  used in simulations
  #' @param q_ratio numeric in [0,1]. the probability used in quantile algorithm.
  #' @param print_test Boolean. print Bellman values.
  #' @param test_week Numeric of length 1. number of the week to print in test.
  #' @param counter Numeric of length 1. number of the week in calculation.
  #' @param correct_outliers If TRUE, outliers in Bellman values are replaced by spline
  #'   interpolations. Defaults to FALSE.
  #' @param inaccessible_states Boolean. True to delete inaccessible states of any scenario in the result.
  #' @param ... further arguments passed to or from other methods.
  #' @return a \code{data.table} like Data_week with the Bellman values
  #' @importFrom stats ave quantile
  #' @export


  Bellman <- function(Data_week,next_week_values_l,decision_space,E_max,P_max=0,
                      niveau_max,method,na_rm=TRUE,max_mcyear,print_test=FALSE,
                      correct_outliers=FALSE,q_ratio=0.75,test_week,counter,inaccessible_states=F,...){



    decision_space <- unlist(decision_space, use.names = FALSE)
    decision_space <- round(decision_space)
    alpha <- getOption(x = "watervalues.alpha", default = 0.0001)
    decimals <- getOption(x = "watervalues.decimals", default = 3)

    {
    for (i in (1:nrow(Data_week))){
      #init
      {
        states <- Data_week$states[i]
        statesID <- Data_week$statesid[i]
        level_high <- Data_week$level_high[i]
        level_low <- Data_week$level_low[i]
        value_inflow <- Data_week$hydroStorage[i]
        reward <- Data_week$reward[[i]]
        states_next <- Data_week$states_next[[i]]


        value_reward <- unlist(reward, use.names = FALSE)
        states_next <- unlist(states_next, use.names = FALSE)



        if (i%% (nrow(Data_week)/max_mcyear) ==1){
          next_week_values <- next_week_values_l[i:(i+(nrow(Data_week)/max_mcyear)-1)]
        }



        }



    #eliminate non accessible states
    if (states > round(level_high, decimals) - alpha) {
      Data_week$value_node[i] <- -Inf
      next
    }
    if (states < round(level_low, decimals) + alpha) {
      Data_week$value_node[i] <- -Inf
      next
    }


    # max possible decision --------

    largest_decisions <- largest_decisions(states,value_inflow,niveau_max,E_max,P_max)

    largest_turb <-largest_decisions$largest_turb

    largest_pump <- largest_decisions$largest_pump



    # the decisions that respect the max possible decision used in simulation constraints

    decisions_current <- check_largest_decisions(decision_space,largest_decisions,alpha)


    # Possible next states
    next_states <- states_next[states_next >= (states - E_max + value_inflow) & states_next <= (states + P_max + value_inflow + alpha) ]



    # Turbaned energy per transition

    turbined_energy <- turbined_energy(states,next_states,value_inflow,decisions_current,largest_decisions)

    #add element to decisions_current to cover all needed information in the future
    decisions_cover <-decisions_cover(turbined_energy,decisions_current)

    # List of accessible Rewards

    step_reward <- accessible_rewards(decisions_cover,decision_space,value_reward)

    provisional_steps <- step_reward$steps
    provisional_reward_line <- step_reward$rewards


    decisions <- generate_decisions(turbined_energy,decisions_cover,E_max,P_max)



    decision_rewards <- generate_decisions_rewards(decisions,step_reward,alpha)


    # respect the guide graph constraints

    decisions <-  guide_cs_check(decisions,states,value_inflow,level_high,level_low,alpha)


    # Bellman calculator
    Bellman_values <- bellman_calculator(decisions,next_week_values,decision_rewards,states,value_inflow,niveau_max,states_next,alpha,na_rm)








    max_Bell <- max(Bellman_values, na.rm = TRUE)
    Data_week$value_node[i] <- max_Bell
    if(length(decisions)>0){
      Data_week$transition[i] <- decisions[which(Bellman_values==max_Bell)]
    }

  #----- little test -----

    if(is.numeric(test_week)){
     if (counter==test_week){
     print(sprintf("******Week %d *********",counter))
     print(sprintf("State: %d",states))
     print(sprintf("StateID: %d",statesID))
     print(sprintf("Decisions :  "))
     print(decisions)
     print(sprintf("Rewards : "))
     print(Bellman_values)
     print(sprintf("BELLMAN >>>>> %f",Data_week$value_node[i]))
     writeLines("#######--------------------###########\n")
   }}


    }
    }


  #------ mean-grid method---------

  if (method == "mean-grid") {
    if (correct_outliers) {
      Data_week[, value_node := correct_outliers(value_node), by = years]
    }
      return(Data_week)
  }

  #------ grid-mean method---------

  if(method=="grid-mean"){
    if (correct_outliers) {
      Data_week[, value_node := correct_outliers(value_node)]
    }
    if(inaccessible_states){
      Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=mean_or_inf)
    }else{
      Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=mean_finite)
    }
      return(Data_week)
  }

  if (method=="quantile"){
    if (correct_outliers) {
      Data_week[, value_node := correct_outliers(value_node)]
    }
    if(inaccessible_states){
    Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=function(x) quantile_or_inf(x,q_ratio))
    }else{
    Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=function(x) stats::quantile(x, q_ratio))

    }


    return(Data_week)
  }




     return(Data_week)

    }






  #' Compute Bellman values at step i from step i+1
  #'
  #' @param Data_week A "data.table" generated in Grid_Matrix code
  #' that contains:
  #'  * states Numeric. All the water values that can be set, listed in
  #'   decreasing order.
  #'  * value_inflow Numeric. Inflow values for each Monte-Carlo year.
  #'  * Rewards for each simulation value and each Monte-Carlo year.
  #'  * level_high Numeric. Highest possible reservoir value.
  #'  * level_low Numeric. Lowest possible reservoir value.
  #'  * states_next List of vectors enumerating all reachable states
  #' @param decision_space Simulation constraints values
  #' @param next_week_values_l Numeric. Bellman values at step i+1.
  #' @param niveau_max Numeric of length 1. Reservoir capacity.
  #' @param E_max Numeric of length 1. Maximum energy that can be generated by
  #'   hydro storage over one step of time.
  #' @param P_max Numeric of length 1. Maximum energy that can be pumped to
  #' reservoir over one step of time.
  #' @param method Character. Perform mean of grids algorithm or grid of means algorithm or
  #'  grid of quantile algorithm.
  #' @param na_rm Boolean. Remove NAs
  #' @param max_mcyear Numeric of length 1. Number of Monte-Carlo year
  #'  used in simulations
  #' @param q_ratio numeric in [0,1]. the probability used in quantile algorithm.
  #' @param print_test Boolean. print Bellman values.
  #' @param test_week Numeric of length 1. number of the week to print in test.
  #' @param counter Numeric of length 1. number of the week in calculation.
  #' @param correct_outliers If TRUE, outliers in Bellman values are replaced by spline
  #'   interpolations. Defaults to FALSE.
  #' @param inaccessible_states Boolean. True to delete unaccessible states of any scenario in the result.
  #' @param ... further arguments passed to or from other methods.
  #' @return a \code{data.table} like Data_week with the Bellman values
  #' @importFrom stats ave quantile
  #' @importFrom foreach foreach `%dopar%` `%do%`
  #' @export


  Bellman_parallel <- function(Data_week,next_week_values_l,decision_space,E_max,P_max,
                      niveau_max,method,na_rm=TRUE,max_mcyear,print_test=FALSE,
                      correct_outliers=FALSE,q_ratio=0.75,test_week,counter,inaccessible_states=F,...){


    `%dopar%` <- foreach::`%dopar%`
    `%do%` <- foreach::`%do%`
    decision_space <- unlist(decision_space, use.names = FALSE)
    alpha <- getOption(x = "watervalues.alpha", default = 0.0001)
    decimals <- getOption(x = "watervalues.decimals", default = 3)

    {

      bellman_values <- foreach::foreach (i=1:nrow(Data_week), .combine = 'c',
                                          .multicombine = T ) %dopar% {

            bellman_parallel_value(Data_week,i,next_week_values_l,max_mcyear,
                                   E_max,P_max,niveau_max,na_rm,decision_space,alpha,decimals)


                                          }
    }

    Data_week$value_node <- bellman_values



    #------ mean-grid method---------

    if (method == "mean-grid") {
      if (correct_outliers) {
        Data_week[, value_node := correct_outliers(value_node), by = years]
      }
      return(Data_week)
    }

    #------ grid-mean method---------

    if(method=="grid-mean"){
      if (correct_outliers) {
        Data_week[, value_node := correct_outliers(value_node)]
      }
      if(inaccessible_states){
        Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=mean_or_inf)
      }else{
        Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=mean_finite)
      }
      return(Data_week)
    }

    if (method=="quantile"){
      if (correct_outliers) {
        Data_week[, value_node := correct_outliers(value_node)]
      }
      if(inaccessible_states){
        Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=function(x) quantile_or_inf(x,q_ratio))
      }else{
        Data_week$value_node <- stats::ave(Data_week$value_node, Data_week$statesid, FUN=function(x) stats::quantile(x, q_ratio))

      }


      return(Data_week)
    }




    return(Data_week)

  }


  #' Compute Bellman values at step i from step i+1 (version used in parallel computing)
  #'
  #' @param Data_week A "data.table" generated in Grid_Matrix code
  #' that contains:
  #'  * states Numeric. All the water values that can be set, listed in
  #'   decreasing order.
  #'  * value_inflow Numeric. Inflow values for each Monte-Carlo year.
  #'  * Rewards for each simulation value and each Monte-Carlo year.
  #'  * level_high Numeric. Highest possible reservoir value.
  #'  * level_low Numeric. Lowest possible reservoir value.
  #'  * states_next List of vectors enumerating all reachable states
  #' @param i the row number of the point to calculate her bellman value.
  #' @param decision_space Simulation constraints values
  #' @param next_week_values_l Numeric. Bellman values at step i+1.
  #' @param niveau_max Numeric of length 1. Reservoir capacity.
  #' @param E_max Numeric of length 1. Maximum energy that can be generated by
  #'   hydro storage over one step of time.
  #' @param P_max Numeric of length 1. Maximum energy that can be pumped to
  #' reservoir over one step of time.
  #' @param na_rm Boolean. Remove NAs
  #' @param max_mcyear Numeric of length 1. Number of Monte-Carlo year
  #'  used in simulations
  #' @param alpha maximum tolerance.
  #' @param decimals number of decimals.
  #' @return a \code{data.table} like Data_week with the Bellman values
  #' @importFrom stats ave quantile
  #' @export

  bellman_parallel_value <- function(Data_week,i,next_week_values_l,max_mcyear,
                                     E_max,P_max,niveau_max,na_rm
                                     ,decision_space,alpha,decimals){


  #init
  {
    states <- Data_week$states[i]
    statesID <- Data_week$statesid[i]
    level_high <- Data_week$level_high[i]
    level_low <- Data_week$level_low[i]
    value_inflow <- Data_week$hydroStorage[i]
    reward <- Data_week$reward[[i]]
    states_next <- Data_week$states_next[[i]]


    value_reward <- unlist(reward, use.names = FALSE)
    states_next <- unlist(states_next, use.names = FALSE)


    next_week_values <- next_week_value(next_week_values_l,max_mcyear,i)

  }



  #eliminate non accessible states
  if (states > round(level_high, decimals) - alpha) {
    return( -Inf)

  }
  if (states < round(level_low, decimals) + alpha) {
    return(-Inf)

  }


  # max possible decision --------
  largest_turb <- min(c(states + value_inflow, E_max,niveau_max), na.rm = TRUE)
  largest_turb <- round(largest_turb, decimals) ###


  largest_pump <- -min(c(niveau_max-(states + value_inflow), P_max), na.rm = TRUE)
  largest_pump <- round(largest_pump, decimals) ###



  # the decisions that respect the max possible decision used in simulation constraints
  decisions_current <- decision_space[decision_space <= largest_turb + alpha]
  decisions_current <- decision_space[decision_space >= largest_pump + alpha]
  decisions_current <- round(decisions_current, decimals) ###


  # Possible next states
  next_states <- states_next[states_next >= (states - E_max + value_inflow) & states_next <= (states + P_max + value_inflow + alpha) ]



  # Turbaned energy per transition
  turbined_energy <- states - next_states + value_inflow
  turbined_energy <- round(turbined_energy, decimals) ###

  turbined_energy <- turbined_energy[turbined_energy<=largest_turb]
  turbined_energy <- turbined_energy[turbined_energy<=max(decisions_current)]

  turbined_energy <- turbined_energy[turbined_energy>=largest_pump]
  turbined_energy <- turbined_energy[turbined_energy>=min(decisions_current)]


  if((largest_turb)>max(turbined_energy))
  {
    turbs <- decisions_current[decisions_current>0]
    turbs_dec <- decision_space[decision_space>0]
    decisions_current <- append(decisions_current,
                                      turbs_dec[(length(turbs)+1)],after = length(decisions_current))
  }

  if((largest_pump)<min(turbined_energy)){
    #add element to decisions_current
    pumps <- decisions_current[decisions_current<=0]
    pumps_dec <- decision_space[decision_space<=0]
    decisions_current <- append(decisions_current,
                                      pumps_dec[(length(pumps_dec)-length(pumps))],after =0)
  }


  # List of accessible Rewards
  if(largest_turb>E_max){ provisional_steps <- unique(c(decisions_current, E_max) )
  }else {provisional_steps <- unique(decisions_current)}

  if(abs(largest_pump)>P_max){ provisional_steps <- unique(c(decisions_current, P_max) )
  }else {provisional_steps <- unique(decisions_current)}

  provisional_reward_line <- unique(c(value_reward[seq_along(decisions_current)]))

  decisions <- unique(sort(c(turbined_energy, decisions_current), decreasing = FALSE))



  #testing rmv NA
  provisional_steps <- provisional_steps[!is.na(provisional_steps)]

  if (length(setdiff(turbined_energy, decisions_current)) > 0) {

    # boucle sur les quantité de turbinaga possible
    for (index in setdiff(turbined_energy, decisions_current)) { # index <- 70000 MWh

      # Closest inf simulation constraint
      before <- provisional_steps[index >= provisional_steps - alpha]
      before <- before[length(before)]

      # Closest sup simulation constraint
      after <- provisional_steps[index <= provisional_steps + alpha]
      after <- after[1]

      # For interpolation
      remainder <- (index -  before ) / (after - before)
      # remainder <- round(remainder, decimals) ###
      # remainder <- abs(remainder - trunc(remainder))

      # index_before <- match(before, provisional_steps)
      index_before <- which(num_equal(before, provisional_steps))
      index_before <- round(index_before)
      # index_after <- match(after, provisional_steps)
      index_after <- which(num_equal(after, provisional_steps))
      index_after <- round(index_after)

      # calculate interpolated reward
      interpolation_current_benef <- provisional_reward_line[index_before]*(1-remainder) + provisional_reward_line[index_after]*remainder


      provisional_steps <- unique(sort(c(index, provisional_steps), decreasing = FALSE))

      new_reward_element <- interpolation_current_benef


      # add the reward to the list keeping the increasing order of turbaned energy
      provisional_reward_line <- c(provisional_reward_line[seq_len(index_before)],
                                   new_reward_element, provisional_reward_line[index_after:length(provisional_reward_line)])

    } # fin boucle sur  sur les quantité de turbinaga possible

  } # fin if


  # respect the guide graph constraints
  decisions <- decisions[decisions - alpha <= states + value_inflow - level_low]

  decisions <- decisions[decisions + alpha >= states + value_inflow - level_high]

  decisions <- round(decisions, decimals) ###


  # initialize
  tempo <- vector(mode = "numeric", length = length(decisions))
  count_x <- 0



  for (l in decisions) { # l <- 0

    count_x <- count_x + 1


    # Respect Reservoir Capacity
    if ((states - l + value_inflow) >= niveau_max + alpha) {
      next
    }


    states_above <- states_next[states_next > (states - l + value_inflow) - alpha]
    states_below <- states_next[states_next <= (states - l + value_inflow) + alpha]

    next_node_up <- which(num_equal(states_above[length(states_above)], states_next))
    next_node_down <- which(num_equal(states_below[1], states_next))

    remainder <- 0

    if (!num_equal(next_node_up, next_node_down)) {
      remainder <- ((states - l + value_inflow) -states_below[1]) / (states_above[length(states_above)] - states_below[1])
    } else {
      remainder <- 0
    }

    # Bellman value of the next week
    vunw <- next_week_values[next_node_up]
    # if (!is.finite(vunw))
    #    vunw <- 0
    vdnw <- next_week_values[next_node_down]
    # if (!is.finite(vdnw))
    #   vdnw <- 0
    interpolation <- remainder * vunw + (1 - remainder) * vdnw


    tempo[count_x] <- sum(c(provisional_reward_line[num_equal(l, provisional_steps)], interpolation), na.rm = na_rm)
  }



  return(max(tempo, na.rm = TRUE))

  }



#' An intermediate function in bellman values calculation.
#' Select the next week bellman values of a position from all bellman values.
#' @param  next_week_values_l list of all bellman values of the next week.
#' @param max_mcyear the maximum number of scenarios.
#' @param i the number of row in the table of calculation.
#' @export

next_week_value <- function(next_week_values_l,max_mcyear,i){

  year_rows <- length(next_week_values_l)/max_mcyear

  r <- (i)%/%year_rows
  if(i%%year_rows==0) r <- r-1
  next_week_values <- next_week_values_l[((r*year_rows)+1):(((r+1)*year_rows))]

  return(next_week_values)


}



