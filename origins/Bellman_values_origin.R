
#' Compute Bellman values at step i from step i+1
#'
#' @param states Numeric. All the water values that can be set, listed in
#'   decreasing order.
#' @param states_next List of vectors enumerating all reachable states?
#' @param value_reward A data.table. Rewards for each simulation value and each
#'   Monte-Carlo year.
#' @param value_inflow Numeric. Inflow values for each Monte-Carlo year.
#' @param decision_space Simulation values?
#' @param level_high Numeric. Highest possible reservoir value.
#' @param level_low Numeric. Lowest possible reservoir value.
#' @param value_node_next_week Numeric. Bellman values at step i+1.
#' @param niveau_max Numeric of length 1. Reservoir capacity.
#' @param E_max Numeric of length 1. Maximum energy that can be generated by
#'   hydro storage over one step of time.
#' @param method Character. Perform mean grid algorithm or grid mean algorithm?
#' @param na_rm Boolean. Remove NAs

calculate_value_node <- function(states, states_next, value_reward, value_inflow, decision_space,
                                 level_high, level_low, value_node_next_week, niveau_max = 10, E_max = 1.344, method, na_rm = FALSE) {

  value_reward <- unlist(value_reward, use.names = FALSE)
  decision_space <- unlist(decision_space, use.names = FALSE)
  states_next <- unlist(states_next, use.names = FALSE)

  alpha <- getOption(x = "antaresWaterValues.alpha", default = 0.0001)
  decimals <- getOption(x = "antaresWaterValues.decimals", default = 3)

  # value_node_year <- rep(NA_real_, times = length(states))
  #
  if (states >= round(level_high, decimals) - alpha) {
    return(-Inf)
  }
  if (states <= round(level_low, decimals) + alpha) {
    return(-Inf)
  }


  largest_decision <- min(c(states + value_inflow, E_max), na.rm = TRUE)

  largest_decision <- round(largest_decision, decimals) ###
  decisions_current_benef <- decision_space[decision_space <= largest_decision + alpha]
  decisions_current_benef <- round(decisions_current_benef, decimals) ###

  provisional_steps <- unique(c(decisions_current_benef, E_max) )
  provisional_reward_line <- unique(c(value_reward[seq_along(decisions_current_benef)] , value_reward[length(value_reward)]))

  next_states <- states_next[states_next >= (states - E_max + value_inflow) & states_next <= (states + value_inflow + alpha) ]

  decisions_benef_to_go <- states - next_states + value_inflow
  decisions_benef_to_go <- round(decisions_benef_to_go, decimals) ###

  decisions <- unique(sort(c(decisions_benef_to_go, decisions_current_benef), decreasing = FALSE))

  # if (any(!decisions_benef_to_go %in% decisions_current_benef)) {
  if (length(setdiff(decisions_benef_to_go, decisions_current_benef)) > 0) {

    # boucle sur ?
    for (index in setdiff(decisions_benef_to_go, decisions_current_benef)) { # index <- 0.008604931

      before <- provisional_steps[index >= provisional_steps - alpha]
      before <- before[length(before)]

      after <- provisional_steps[index <= provisional_steps + alpha]
      after <- after[1]

      remainder <- (index -  before ) / (after - before)
      remainder <- round(remainder, decimals) ###
      remainder <- abs(remainder - trunc(remainder))

      # index_before <- match(before, provisional_steps)
      index_before <- which(num_equal(before, provisional_steps))
      index_before <- round(index_before)
      # index_after <- match(after, provisional_steps)
      index_after <- which(num_equal(after, provisional_steps))
      index_after <- round(index_after)

      interpolation_current_benef <- provisional_reward_line[index_before]*(1-remainder) + provisional_reward_line[index_after]*remainder


      provisional_steps <- unique(sort(c(index, provisional_steps), decreasing = FALSE))

      new_reward_element <- interpolation_current_benef



      provisional_reward_line <- c(provisional_reward_line[seq_len(index_before)],
                                   new_reward_element, provisional_reward_line[index_after:length(provisional_reward_line)])

    } # fin boucle sur ?

  } # fin if


  decisions <- decisions[decisions - alpha <= states + value_inflow - level_low]

  decisions <- decisions[decisions + alpha >= states + value_inflow - level_high]

  decisions <- round(decisions, decimals) ###


  temp <- vector(mode = "numeric", length = length(decisions))
  count_x <- 0

  for (l in decisions) { # l <- 0

    count_x <- count_x + 1

    if ((states - l + value_inflow) >= niveau_max + alpha) {
      next
    }

    #interpolation
    {
    states_above <- states_next[states_next >= (states - l + value_inflow) - alpha]
    states_below <- states_next[states_next <= (states - l + value_inflow) + alpha]

    next_node_up <- which(num_equal(states_above[length(states_above)], states_next))
    next_node_down <- which(num_equal(states_below[1], states_next))

    remainder <- 0

    if (!num_equal(next_node_up, next_node_down)) {
      remainder <- (states - l + value_inflow) %% (states_above[length(states_above)] - states_below[1])
    } else {
      remainder <- 0
    }

    vunw <- value_node_next_week[next_node_up]

    vdnw <- value_node_next_week[next_node_down]

    interpolation <- remainder * vunw + (1 - remainder) * vdnw
    }


    temp[count_x] <- sum(c(provisional_reward_line[num_equal(l, provisional_steps)], interpolation), na.rm = na_rm)
  }

  if (method == "mean-grid") {
    max(temp, na.rm = TRUE)
  } else {
    mean_finite(temp)
  }
}


